<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: String | JustDoit]]></title>
  <link href="http://zhanheng.github.io/blog/categories/string/atom.xml" rel="self"/>
  <link href="http://zhanheng.github.io/"/>
  <updated>2016-06-11T16:57:11+08:00</updated>
  <id>http://zhanheng.github.io/</id>
  <author>
    <name><![CDATA[ZhanHeng]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[字符串加密]]></title>
    <link href="http://zhanheng.github.io/blog/2016/05/14/StringEncrypt/"/>
    <updated>2016-05-14T23:10:30+08:00</updated>
    <id>http://zhanheng.github.io/blog/2016/05/14/StringEncrypt</id>
    <content type="html"><![CDATA[<h4>选择一个单词作为密钥，然后输入明文。输出密文</h4>

<p>举例：
选择一个单词作为密匙：TRAILBLAZERS<br/>
明文Attack AT DAWN(黎明时攻击)</p>

<p>如果单词中包含有重复的字母，只保留第1个，其余几个丢弃。现在，修改过的那个单词置于字母表的下面，如下所示：</p>

<p>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</p>

<p>T R A I L B Z E S C D F G H J K M N O P Q U V W X Y</p>

<p>其他的用字母表中剩余的字母填充完整。在对信息进行加密时，信息中的每个字母被固定于顶上那行，并用下面那行的对应字母一一取代原文的字母(字母字符的大小写状态应该保留)。</p>

<p>所以最后的密文是 <strong>Tpptad TP ITVH</strong></p>

<p>{% codeblock  字符串加密 %}
public static String encrypt(String key, String data ){
       List<Character> list = new ArrayList<Character>();
       String p = &ldquo;abcdefghijklmnopqrstuvwxyz&rdquo;;
       String res = &ldquo;&rdquo;;
        // 去重
       for(int i = 0 ; i&lt;key.length() ;i++){
           if(!list.contains(key.charAt(i))){
               list.add(key.charAt(i));
               res+=key.charAt(i);
           }
       }
        // 拼接
       StringBuilder sb = new StringBuilder();
       sb.append(res);
       for (int i = 0; i &lt; p.length(); i++) {
           if (!sb.toString().contains(p.substring(i, i+1).toLowerCase())
               &amp;&amp;!sb.toString().contains(p.substring(i, i+1).toUpperCase())) {
               sb.append(p.charAt(i));
           }
       }
       String result = &ldquo;&rdquo;;
       String str = data.toLowerCase();
       String temp= sb.toString();
       //处理输出
       for (int i = 0; i &lt; str.length(); i++) {
          int index= p.indexOf(str.substring(i, i+1));//找到字符出现的位置
          if (Character.isLowerCase(data.charAt(i))) {// 小写字母
              result+= Character.toLowerCase(temp.charAt(index)) ;
          }else if(Character.isUpperCase(data.charAt(i))){// 大写字母
              result+= Character.toUpperCase(temp.charAt(index)) ;
          }else // 处理非字母的
              result+=data.charAt(i);
       }
       return result;
    }
{% endcodeblock %}</p>

<h3>把一个字符串的大写字母放到字符串的后面，各个字符的相对位置不变，不能申请额外的空间</h3>

<p>借助冒泡排序的思想，大写字母往后移动，小写字母往前移动。</p>

<p>{% codeblock   %}
public static String sort(String string) {
        int y = 0;
        int nLen = string.length();
        char[] str = string.toCharArray();
        for (int i = nLen - 1; i >= 0; i&ndash;) {
            if (str[i] >= &lsquo;A&rsquo; &amp;&amp; str[i] &lt;= &lsquo;Z&rsquo;) {
                char temp = str[i]; //值存起来
                int k = i;          //下标存起来
                for (; k &lt; nLen - 1 - y; k++)
                    str[k] = str[k + 1]; //小写字母往前移动
                str[k] = temp;  //把大写字母放到后边去
                y++;            //大写字母个数
            }
        }
        return String.valueOf(str);
    }
{% endcodeblock %}</p>
]]></content>
  </entry>
  
</feed>
